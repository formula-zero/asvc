use std::io::Error; // temp. r1cs::SynthesisError
use std::{ops::{Div, MulAssign}, usize};

use ark_ec::msm::VariableBaseMSM;
use ark_ec::{AffineCurve, PairingEngine, ProjectiveCurve, msm::FixedBaseMSM};
use ark_ff::{Field, One, PrimeField, UniformRand};
use ark_std::rand::Rng;   // in ver3.0 of ark_ec, use ark_std instead of rand::Rng
use ark_poly::{EvaluationDomain, GeneralEvaluationDomain};

use core::ops::{Sub};

// Module explanation
// - ark_poly::GeneralEvaluationDomain
//    : Defines a domain over which finite field (I)FFTs can be performed. 
//    Generally tries to build a radix-2 domain and falls back to a mixed-radix domain 
//    if the radix-2 multiplicative subgroup is too small.
// - ark_poly::EvaluationDomain
//    : Defines a domain over which finite field (I)FFTs can be performed. 
//    The size of the supported FFT depends on the size of the multiplicative subgroup. 
//    For efficiency, we recommend that the field has at least one large subgroup generated by a root of unity.
// - ark_ec::msm::FixedBaseMSM
//    : MSM - Multi Scalar Multiplication
pub struct UpdateKey<E: PairingEngine>{
  pub a_i: E::G1Affine,
  pub u_i: E::G1Affine,
}

pub struct ProvingKey<E: PairingEngine> {
  pub list_g1_tau_i: Vec<E::G1Affine>,  // g^(tau^i), vector-length:n
  pub list_l_i: Vec<E::G1Affine>,        // l_i
  pub list_update_keys: Vec<UpdateKey<E>>,
}

pub struct VerifyingKey<E: PairingEngine> {
  pub list_g1_tau_i: Vec<E::G1Affine>,  // g^(tau^i), vector-length: |I|
  pub list_g2_tau_i: Vec<E::G2Affine>,
  pub a: E::G1Affine,              // a
}

pub struct Parameters<E: PairingEngine> {
  pub proving_key: ProvingKey<E>,
  pub verifying_key: VerifyingKey<E>,
}

#[derive(Clone, Eq, PartialEq)]
pub struct Commitment<E: PairingEngine> {
  pub commit: E::G1Affine,
}

fn group_gen<E: PairingEngine> (domain: &GeneralEvaluationDomain<E::Fr>) -> E::Fr {
  match domain {
    GeneralEvaluationDomain::Radix2(radix) => radix.group_gen,
    GeneralEvaluationDomain::MixedRadix(mixed ) => mixed.group_gen,
  }
}

pub fn key_gen<E: PairingEngine, R: Rng> (n: usize, rng: &mut R) -> Result<Parameters<E>, Error> {
  // rand from ark_ff::{UniformRand}
    // type Fr: PrimeField + SquareRootField - This is the scalar field of the G1/G2 groups.
  let tau = E::Fr::rand(rng);
  let g1 = E::G1Projective::rand(rng);
  let g2 = E::G2Projective::rand(rng);

  // Evaluation Domain - Subgroup!! <Not Fully Understood..>
  let domain: GeneralEvaluationDomain<E::Fr> = 
    EvaluationDomain::<E::Fr>::new(n).unwrap();//.ok_or(Error(0))?;
  let max_degree = domain.size();

  let scalar_bit = E::Fr::size_in_bits(); // size_in_bits from ark_ff::PrimeField
  let g1_window = FixedBaseMSM::get_mul_window_size(max_degree+1);
  let g1_table = FixedBaseMSM::get_window_table::<E::G1Projective>(scalar_bit, g1_window, g1);

  let g2_window = FixedBaseMSM::get_mul_window_size(max_degree+1);
  let g2_table = FixedBaseMSM::get_window_table::<E::G2Projective>(scalar_bit, g2_window, g2);

  let mut curs = vec![E::Fr::one()];  // one from ark_ff::One
  let mut cur = tau;

  for _ in 0..max_degree {
    curs.push(cur);
    cur.mul_assign(&tau); // num * G
  }

  // n-SDH public parameters : g, g^τ , g^(τ^2), ... g^(τ^n)

  let mut list_g1_tau_i = 
    FixedBaseMSM::multi_scalar_mul(scalar_bit, g1_window, &g1_table, &curs);
  // batch_normalization_into_affine from ark_ec::ProjectiveCurve trait
    // Normalizes a slice of projective elements and outputs a vector containing the affine equivalents.
  let list_g1_tau_i = E::G1Projective::batch_normalization_into_affine(&mut list_g1_tau_i);

  let mut list_g2_tau_i =
    FixedBaseMSM::multi_scalar_mul(scalar_bit, g2_window, &g2_table, &curs);
  let list_g2_tau_i = E::G2Projective::batch_normalization_into_affine(&mut list_g2_tau_i);
  
  // a = g^A(τ) when A(τ) = τ^n - 1 .. (why sub g1, not 1 ??)
  let a = list_g1_tau_i[max_degree].into_projective().sub(&g1); // sub from core::ops::{Sub} trait

  let mut update_keys : Vec<UpdateKey<E>> = Vec::new();
  let mut l_of_g1 : Vec<E::G1Projective> = Vec::new();

  for i in 0..max_degree {
    // 1/(τ-ω^i)
    let omega = group_gen::<E>(&domain);
    let omega_i = omega.pow(&[i as u64]);
    let tau_omega_i = tau.sub(&omega_i);
    let tau_omega_i_divisor = E::Fr::one().div(&tau_omega_i);

    // ai = g_1^(A(τ)/(τ-ω^i))  // <E as PairingEngine>::G1Projective
    let a_i = a.mul(tau_omega_i_divisor.into()); 

    // 1/nω^(n-i) = ω^i/n
    let a_aside_omega_i_divisor = group_gen::<E>(&domain)
      .pow(&[i as u64]) // limbs - list of integers
      .div(&E::Fr::from_repr((max_degree as u64).into()).unwrap());
    // from_repr : Returns a prime field element from its underlying representation.

    // li = g_1^L_i(x) = g_1^(A(τ)/((x-ω^i)*A'(ω^i))) = ai^(1/A'(ω^i))
    let l_i = a_i.mul(a_aside_omega_i_divisor.into());  // scalar multiplication

    // ui = (li-1)/(x-ω^i)
    let mut u_i = l_i.sub(&g1);
    u_i = u_i.mul(tau_omega_i_divisor.into());

    // batch_normalization_into_affine?
    let upk = UpdateKey {
      a_i: a_i.into_affine(),
      u_i: u_i.into_affine(),
    };

    update_keys.push(upk);
    l_of_g1.push(l_i);
  }
  let l_of_g1 = E::G1Projective::batch_normalization_into_affine(&mut l_of_g1);

  let params = Parameters::<E> {
    proving_key: ProvingKey::<E> {
      list_g1_tau_i: list_g1_tau_i.clone(),
      list_l_i: l_of_g1,
      list_update_keys: update_keys,
    },
    verifying_key: VerifyingKey::<E> {
      list_g1_tau_i: list_g1_tau_i,
      list_g2_tau_i: list_g2_tau_i,
      a: a.into_affine(),
    },
  };
  Ok(params)
  
}

// TT l_i^(v_i)
pub fn commit<E: PairingEngine>(
  prk_params: &ProvingKey<E>,
  values: Vec<E::Fr>,
) -> Result<Commitment<E>, Error> {

  let num_coefficient = values.len();
  let num_powers = prk_params.list_l_i.len();

  assert!(num_coefficient >= 1);
  assert!(num_coefficient <= num_powers);

  let scalars: Vec<<E::Fr as PrimeField>::BigInt> =
    values.iter().map(|v| v.into_repr()).collect();

  let commit = VariableBaseMSM::multi_scalar_mul(&prk_params.list_l_i, &scalars);

  let c = Commitment::<E> {
    commit: commit.into_affine(),
  };
  
  Ok(c)
}
